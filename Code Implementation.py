# -*- coding: utf-8 -*-
"""Minor Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17GIXWIObR61QATSSgs_9fIHZkJcZt5d-
"""

!pip install pycryptodome
!pip install pyscrypt
from google.colab import files

from Crypto.Cipher import AES
import pyscrypt
import os
import binascii
from PIL import Image
import numpy as np
import matplotlib.pyplot as plt

def encrypt_AES_GCM(password, data):
    kdfSalt = os.urandom(16)
    secretKey = pyscrypt.hash(password, kdfSalt, 1024, 8, 1, 32)
    aesCipher = AES.new(secretKey, AES.MODE_GCM)
    ciphertext, authTag = aesCipher.encrypt_and_digest(data)
    return (kdfSalt, ciphertext, aesCipher.nonce, authTag)

def decrypt_AES_GCM(password, encrypted_data):
    (kdfSalt, ciphertext, nonce, authTag) = encrypted_data
    secretKey = pyscrypt.hash(password, kdfSalt, 1024, 8, 1, 32)
    aesCipher = AES.new(secretKey, AES.MODE_GCM, nonce)
    plaintext = aesCipher.decrypt_and_verify(ciphertext, authTag)
    return plaintext

def main():
    password = input("Enter password: ").encode()
    data = input("Enter data to be encrypted: ").encode()
    encrypted_data = encrypt_AES_GCM(password, data)
    print("Encrypted data:")
    print("kdfSalt:", binascii.hexlify(encrypted_data[0]))
    print("ciphertext:", binascii.hexlify(encrypted_data[1]))
    print("aesIV:", binascii.hexlify(encrypted_data[2]))
    print("authTag:", binascii.hexlify(encrypted_data[3]))
    decrypted_data = decrypt_AES_GCM(password, encrypted_data)
    print("Decrypted data:", decrypted_data.decode())

if __name__ == "__main__":
    main()

# function to convert text to binary string
def text_to_bits(text, encoding='utf-8', errors='surrogatepass'):
    bits = bin(int(binascii.hexlify(text.encode(encoding, errors)), 16))[2:]
    return bits.zfill(8 * ((len(bits) + 7) // 8))

# function to convert binary string to text
def bits_to_text(bits, encoding='utf-8', errors='surrogatepass'):
    n = int(bits, 2)
    return int2bytes(n).decode(encoding, errors)

# function to convert integer to bytes
def int2bytes(i):
    hex_string = '%x' % i
    n = len(hex_string)
    return binascii.unhexlify(hex_string.zfill(n + (n & 1)))

# user input text to hide in image
text = input("Enter the text to hide in the image: ")

# open the image file
img_file = input("Enter the image filename (with extension): ")
img = Image.open(img_file)

# convert text to binary string
bits = text_to_bits(text)

# check if image has enough pixels to store the text
if len(bits) > img.width * img.height:
    print("Error: Image does not have enough pixels to store the text")
    exit()

# convert the image to RGB format
img = img.convert("RGB")

# iterate over each pixel in the image and store the text
index = 0
for x in range(img.width):
    for y in range(img.height):
        if index < len(bits):
            r, g, b = img.getpixel((x, y))
            r_bits, g_bits, b_bits = text_to_bits(str(r)), text_to_bits(str(g)), text_to_bits(str(b))
            r_bits = r_bits[:-1] + bits[index]
            g_bits = g_bits[:-1] + bits[index+1]
            b_bits = b_bits[:-1] + bits[index+2]
            r, g, b = int(r_bits, 2), int(g_bits, 2), int(b_bits, 2)
            img.putpixel((x, y), (r, g, b))
            index += 3
        else:
            break

# save the new image with the text hidden inside
output_filename = "stego_" + img_file
img.save(output_filename)
files.download(output_filename)
print("Steganography complete! The image with hidden text has been saved as", output_filename)



def extract_text_from_image(image_path='/content/stego_kirt.jpeg'):
    img = Image.open(image_path)
    pixels = img.load()

    binary_string = ''
    for y in range(img.size[1]):
        for x in range(img.size[0]):
            r, g, b = pixels[x, y]
            binary_string += bin(r)[-1] + bin(g)[-1] + bin(b)[-1]

    # Convert binary string to text
    text = ''
    for i in range(0, len(binary_string), 8):
        byte = binary_string[i:i+8]
        text += chr(int(byte, 2))

    return text
extract_text_from_image()

# Define the chaotic map
def chaotic_map(x, y, a=1.4, b=0.3, c=1.0, d=0.1):
    x_next = np.sin(a * y) + c * np.cos(a * x)
    y_next = np.sin(b * x) + d * np.cos(b * y)
    return x_next, y_next

# Define the encryption function
def encrypt_image(image_path):
    # Load the image and convert to grayscale
    img = Image.open(image_path).convert('L')
    pixels = np.array(img)

    # Define the initial conditions for the chaotic map
    x, y = 0.1, 0.2

    # Encrypt the image by iterating the chaotic map
    for i in range(pixels.shape[0]):
        for j in range(pixels.shape[1]):
            x, y = chaotic_map(x, y)
            pixels[i, j] ^= int(255 * x * y)

    # Create a new image from the encrypted pixels
    encrypted_img = Image.fromarray(pixels)

    return encrypted_img

# Example usage
image_path = '/content/stego_kirt.jpeg'
encrypted_img = encrypt_image(image_path)
encrypted_img.save('encrypted_img.jpg')
files.download('encrypted_img.jpg')
print("Encryption complete! The image has been saved")